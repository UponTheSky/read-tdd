# Ch30 Design Patterns
- Why Design Pattern?:
    - Most of the problems are generated by the tools we usel not by the external problem at hand
    - So common problems mean common solutions are available

- But the design patterns suggested by GOF is a bit rigorous for TDD
    - > Design in TDD requirems a different look at design patterns

## Command
- When you need the invocation of a computation to be more complicated than a simple method call
- Make an object for the computation, and invoke it

- Doing it in a method requires expensive mechanisms, and once we make an object, we don't need extra cost

## Value Object
- For objects that will be shared, but their identity is not important
    - Set the state when created, and never change it
    - Operations on the object always return a new object, leaving the original one unchanged
    - We can also apply Observer pattern, but then the control flow could be complicated

- eg)Geometric objects

## Null Object
- Create an object representing the special case, instead of checking those special cases  
several times in your code(DRY!)

## Template Method
- Why template? 
    - we want to have a single source-of-truth design
    - DRY

## Pluggable Object
- Rather than conditionals, which may bring about DRY problems, we prefer the Pluggable Object
- Depending on condition, use different object. For each object you implement different interface

## Pluggable Selector
- How to invoke different behavior for different instances?
    - Store the name of a method and dynamically invoke the method!
    - Switch statement in the superclass is not a good idea(DRY in both superclass, 
    and the subclasses themselves)

- Dynamically invoking the method means, using reflection(`__class__`, `getattr`, and `self`)
- Tracing the code to see whether this method is invoked, is a bit complicated
    - recommended to use when each subclass has only one method

## Factory Method
- Create an object when you wnat flexibility in creation
    - Use a method instead of a constructor(which is lack of flexibility)

## Imposter
- Introducing a new variation into a computation:
    - Introduce a new object with the same interface as an existing one
    - But it has a different implementation

- As an antidote against DRY in conditionals(working with Pluggable Object)
- Noticeable imposters: null objects, and composite

## Composite
- How about an object whose behavior is the composition of the behavior of a list of other objects?
    - Make it an Imposter for the component objects

- Personally, I think the example suggested from the book is not clear
    - Why not `OverallAccounts`? It seems to have its own role
    - `Account of Accounts` may produce confusion. Why so serious about DRY to that extent?

## Collecting Parameter
- Collect the result of an operation that is spread over several obejcts?
    - Add a parameter to the operation where the result will be collected

## Singleton
- Please don't use any global variables
